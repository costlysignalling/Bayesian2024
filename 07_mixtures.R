library(rethinking)

# Mixture distributions

# Zero inflated outcomes
prob_drink <- 0.2 # 20% of days the monks drink and do no work
rate_work <- 1    # average 1 manuscript per day (if monks work)

# sample one year of production
N <- 365

# simulate days monks drink
drink <- rbinom(N,1 ,prob_drink)

# simulate manuscripts completed
y <- (1-drink)*rpois(N,rate_work)

#
simplehist(y, xlab="manuscripts completed", lwd=4)
zeros_drink <- sum(drink)
zeros_work <- sum(y==0 & drink==0)
zeros_total <- sum(y==0)
lines( c(0,0) , c(zeros_work,zeros_total) , lwd=4 , col=rangi2 )
#Blue are zeros due to drinking days


# Discrete outcomes and decisions we make
rd<-read.table("DictatorGameHormones.txt",sep="\t",header=T)
summary(rd)

#Get rid of rows with missing values
d1<-rd[complete.cases(rd),]
summary(d1)

#Model the donation in Dictator Game as a response variable predicted by hormonal levels and sex.

#TASK 20: Try to think about how would you do that with what you already know and only later read further
#If you struggle, you can find the solution in TASK_SOLUTIONS.R line 410

#Look what we have here: The response variable is very very not normal
hist(d1$DG_given)
simplehist(d1$DG_given)
d1$DG_given

#But there is a perfect distribution that can describe such system! Think about it as a distribution characterized by two coins, first you flip an (possibly unfair) coin that determines your decision whether to donate half of the budget (200) and if not, you flip the second (possibly unfair) coin 400 times and for each head you donate one token. Sure, you might also end up on 200, but that is not a problem.
#Parameter of each coin can be a function of the predictors (cortisol, testosterone, and sex).
#The first coin toss can be generated by a simple coin with intercept (and possibly other parameters) but the second coin should be drawn from a distibution. Remember the beta distribution?
curve(dbeta(x,shape1=0.5,shape2=0.5)) #shape1 is commonly called alpha, shape2 is called beta

#There is possibly a more useful parametrization with mean (mu, sometimes called "central tendency") and dispersion around it (theta)
mu<-0.3
theta<-20
curve(dbeta(x,shape1=mu*theta,shape2=(1-mu)*theta)) #shape1 is commonly called alpha, shape2 is called beta

v<-rbeta(1000,shape1=mu*theta,shape2=(1-mu)*theta)
mean(v)

#This might be a distribution of heads-probability of unfair coins that characterize the population of participants. Each participant tosses 400 times with the assigned coin. To simulate exacly this, you use the combination of beta and binomial distribution, which is called (unsurprisingly) "beta-binomial distribution"
rbetabinom(n=200,size=400,prob=mu,theta=theta)

#TASK 21: Now that you know beta-binomial distribution, simulate 1000 observations similar to what you see in vector 
d1$DG_given

#If you struggle, you can find the solution in TASK_SOLUTIONS.R line 415

#If you are bored, you can try to simulate the data as coming from 3 and not two coins:
#First coin determines whether you donate anything at all
#If the outcome of the first coin is heads, than the second coin determines, whether you just split the budget in half
#If the outcome of the second coin is tails, you add some nuance and toss the third coin (from a distribution of coins characterised by mu and theta) 400 times to determine the donation.

#Tut in this script, we will stick to two coins. The extension to two binary decisions and generation of a number between 0 and 400 is trivial.

#This example is very much about distributions.
#Cortisol and Testosterone levels are strictly positive numbers so we do not expect them to be normally distributed (and they likely change in multiplicative, not additive fashion). We expect log-normal distribution
plot(density(d1$testosterone))
plot(density(d1$cortisol))

#Let us create two bespoke functions that will make our life easier later
scaleT<-function(x){(log(x)-mean(log(d1$testosterone)))/sd2(log(d1$testosterone))}
descaleT<-function(x){exp(x*sd2(log(d1$testosterone))+mean(log(d1$testosterone)))}

scaleC<-function(x){(log(x)-mean(log(d1$cortisol)))/sd2(log(d1$cortisol))}
descaleC<-function(x){exp(x*sd2(log(d1$cortisol))+mean(log(d1$cortisol)))}

#Test whether the functions work properly
scaleT(d1$testosterone)
head(cbind(descaleT(scaleT(d1$testosterone)),d1$testosterone))

scaleC(d1$cortisol)
head(cbind(descaleC(scaleC(d1$cortisol)),d1$cortisol))

#First, just try to mimic the distribution
d.list<-list(donation=d1$DG_given)

m.distribution<-ulam(alist(
  donation|donation!=200 ~ custom( log1m(p) + beta_binomial_lpmf(donation|400,mu*theta,(1-mu)*theta) ),
  donation|donation==200 ~ custom( log_mix( p , 0 , beta_binomial_lpmf(200 | 400, mu[i]*theta, (1-mu[i])*theta) ) ),
  
  logit(p)<-ap,
  logit(mu)<-amu,
  
  ap~dnorm(0,1),
  amu~dnorm(0,1),
  theta~dexp(1)
),cores=1,chains=1,data=d.list,sample=F) #If does not work, change sample to FALSE and observe the suggested code

#Why does rethinking Stan code writer fucks up?
stancode(m.distribution)

#It forces indexes to some mu. We can modify the resulting code and learn, how to use Stan directly
#We start with
code.m.distribution<-"
data{
    int donation[129];
}
parameters{
    real ap;
    real amu;
    real<lower=0> theta;
}
model{
    real p;
    real mu;
    theta ~ exponential( 1 );
    amu ~ normal( 0 , 1 );
    ap ~ normal( 0 , 1 );
    mu = amu;
    mu = inv_logit(mu);
    p = ap;
    p = inv_logit(p);
    for ( i in 1:129 ) 
        if ( donation[i] == 200 ) target += log_mix(p, 0, beta_binomial_lpmf(200 | 400, mu[i] * theta, (1 - mu[i]) * theta));
    for ( i in 1:129 ) 
        if ( donation[i] != 200 ) target += log1m(p) + beta_binomial_lpmf(donation[i] | 400, mu * theta, (1 - mu) * theta);
}"

#Suggested modification

code.m.distribution<-"
data{
    int N;
    int donation[N];
}
parameters{
    real ap;
    real amu;
    real<lower=0> theta;
}
model{
    real p;
    real mu;
    theta ~ exponential( 1 );
    amu ~ normal( 0 , 1 );
    ap ~ normal( 0 , 1 );
    mu = amu;
    mu = inv_logit(mu);
    p = ap;
    p = inv_logit(p);
    for ( i in 1:N ){
        if ( donation[i] == 200 ) target += log_mix(p, 0, beta_binomial_lpmf(200 | 400, mu * theta, (1 - mu) * theta));
        if ( donation[i] != 200 ) target += log1m(p) + beta_binomial_lpmf(donation[i] | 400, mu * theta, (1 - mu) * theta);
    } 
}"

d.list.stan<-list(N=nrow(d1),
                  donation=d1$DG_given)

m.distribution<-stan(model_code=code.m.distribution,data=d.list.stan,cores=4,chains=4)

save(m.distribution,file="sampled/m.distribution.Rdata")
load("sampled/m.distribution.Rdata")

precis(m.distribution)

exp(-0.2)
exp(-1.14)
1.59

#TASK 22: Simulate data from the posterior and check whether it works
#If you struggle, you can find the solution in TASK_SOLUTIONS.R line 420

#Effects of sex and hormones
table(as.numeric(as.factor(d1$sex)),d1$sex)

d.predictors<-list(N=nrow(d1),
                  sex=as.numeric(as.factor(d1$sex)),
                  t=scaleT(d1$testosterone),
                  c=scaleC(d1$cortisol),
                  donation=d1$DG_given)

#TASK 23: Try to modify the model from code.m.distribution to include linear effects of testosterone and cortisol and their interaction with sex
#The less intuitive blocks are below for convenience
code.m.TC<-"
data{
    int N;
    int sex[N];
    vector[N] t;
    vector[N] c;
    int donation[N];
}
parameters{
    real ap[2];
    real amu[2];
    
    real bTp[2];
    real bTmu[2];
    
    real bCp[2];
    real bCmu[2];
    
    real<lower=0> theta;
}"
#If you struggle, you can find the solution in TASK_SOLUTIONS.R line 430

m.TC<-stan(model_code=code.m.TC,data=d.predictors,cores=4,chains=4)

save(m.TC,file="sampled/m.TC.Rdata")
load("sampled/m.TC.Rdata")

precis(m.TC,depth=2)
plot(coeftab(m.TC),pars=dimnames(coeftab(m.TC)@coefs)[[1]][1:13])

#TASK 24: What does this coefficient table suggests at a first sight? Discuss in small groups.
#If you struggle, you can find the solution in TASK_SOLUTIONS.R line 478

#How would you add interaction between the hormonal levels? Please stand up. Who has an idea can sit down.

#Interaction between the hormonal levels (the multiplicative kind)
code.m.inter<-"
data{
    int N;
    int sex[N];
    vector[N] t;
    vector[N] c;
    int donation[N];
}
parameters{
    real ap[2];
    real amu[2];
    
    real bTp[2];
    real bTmu[2];
    
    real bCp[2];
    real bCmu[2];
    
    real bTCp[2];
    real bTCmu[2];
    
    real<lower=0> theta;
}
model{
    real p;
    real mu;

    ap ~ normal( 0 , 1 );
    amu ~ normal( 0 , 1 );
    
    bTp ~ normal( 0 , 1 );
    bTmu ~ normal( 0 , 1 );
    
    bCp ~ normal( 0 , 1 );
    bCmu ~ normal( 0 , 1 );
    
    bTCp ~ normal( 0 , 1 );
    bTCmu ~ normal( 0 , 1 );
    
    theta ~ exponential( 1 );

    for ( i in 1:N ){
        p = ap[sex[i]]+bTp[sex[i]]*t[i]+bCp[sex[i]]*c[i]+bTCp[sex[i]]*t[i]*c[i];
        p = inv_logit(p);
    
        mu = amu[sex[i]]+bTmu[sex[i]]*t[i]+bCmu[sex[i]]*c[i]+bTCmu[sex[i]]*t[i]*c[i];
        mu = inv_logit(mu);
    
        if ( donation[i] == 200 ) target += log_mix(p, 0, beta_binomial_lpmf(200 | 400, mu * theta, (1 - mu) * theta));
        if ( donation[i] != 200 ) target += log1m(p) + beta_binomial_lpmf(donation[i] | 400, mu * theta, (1 - mu) * theta);
    }
}"


m.inter<-stan(model_code=code.m.inter,data=d.predictors,cores=4,chains=4)

save(m.inter,file="sampled/m.inter.Rdata")
load("sampled/m.inter.Rdata")

precis(m.inter,depth=2)
plot(coeftab(m.inter),pars=dimnames(coeftab(m.inter)@coefs)[[1]][1:17])

post<-extract.samples(m.inter)
str(post)
str(post[1:9])

#Correlation between parameter values across samples
library(corrplot)
postdat<-as.data.frame(matrix(unlist(post[1:9]),nrow=4000))

names(postdat)<-c(paste(rep(names(post[1:8]),each=2),rep(c("[1]","[2]"),times=8),sep=""),"theta")
corrplot.mixed(cor(postdat),upper="ellipse",tl.pos="lt")

#Visualization colors
sexcol<-c("#FF6600","#0066FF")

#Draw contrafactual plots that investigate possible mediation level of C on T
#We will draw a line around growing testosterone for minimum, median, and maximum level of C, separately for men and women

attach(post)
str(ap)
ns<-dim(ap)[1]

seqT<-scaleT(seq(min(d1$testosterone),max(d1$testosterone),l=100))
sex<-1 #females
c<-scaleC(quantile(d1$cortisol,0.25))

logit.p<-sapply(1:ns,function(i){ap[i,sex]+bTp[i,sex]*seqT+bCp[i,sex]*c+bTCp[i,sex]*seqT*c})
logit.mu<-sapply(1:ns,function(i){amu[i,sex]+bTmu[i,sex]*seqT+bCmu[i,sex]*c+bTCmu[i,sex]*seqT*c})
pred.p<-inv_logit(logit.p)
pred.mu<-inv_logit(logit.mu)
predF1<-pred.p*200+(1-pred.p)*pred.mu*400

par(mfrow=c(1,3))
plot(d1$testosterone,d1$DG_given,type="n",xlab="Testosterone",ylab="donation",main="Cortisol low",xaxs="i",yaxs="i")
abline(h=seq(50,250,50),lty=2,col="grey")

lines(descaleT(seqT),apply(predF1,1,mean),col=sexcol[1])
shade(apply(predF1,1,PI),descaleT(seqT),col=col.alpha(sexcol[1],0.2))

#TASK 25: wrap the construction of contrafactual predictions into a  function and draw the same plot for men at low cortisol, and both sexes in the other two other levels
#If you struggle, you can find the solution in TASK_SOLUTIONS.R line 482

#By the way, if you want to save a nice image like this, use a function rather than the exporting tool above the plotting region

tiff("plot.hormones.tif",width=21,height=8,units="cm",res=600,compression="lzw")

plotAgain<-function(){
  par(mfrow=c(1,3))
  plot(d1$testosterone,d1$DG_given,type="n",xlab="Testosterone",ylab="donation",main="Cortisol low",xaxs="i",yaxs="i")
  abline(h=seq(50,250,50),lty=2,col="grey")
  lines(descaleT(seqT),apply(predF1,1,mean),col=sexcol[1])
  shade(apply(predF1,1,PI),descaleT(seqT),col=col.alpha(sexcol[1],0.2))
  lines(descaleT(seqT),apply(predM1,1,mean),col=sexcol[2])
  shade(apply(predM1,1,PI),descaleT(seqT),col=col.alpha(sexcol[2],0.2))
  
  plot(d1$testosterone,d1$DG_given,type="n",xlab="Testosterone",ylab="",main="Cortisol median",xaxs="i",yaxs="i")
  abline(h=seq(50,250,50),lty=2,col="grey")
  lines(descaleT(seqT),apply(predF2,1,mean),col=sexcol[1])
  shade(apply(predF2,1,PI),descaleT(seqT),col=col.alpha(sexcol[1],0.2))
  lines(descaleT(seqT),apply(predM2,1,mean),col=sexcol[2])
  shade(apply(predM2,1,PI),descaleT(seqT),col=col.alpha(sexcol[2],0.2))
  
  plot(d1$testosterone,d1$DG_given,type="n",xlab="Testosterone",ylab="",main="Cortisol high",xaxs="i",yaxs="i")
  abline(h=seq(50,250,50),lty=2,col="grey")
  lines(descaleT(seqT),apply(predF3,1,mean),col=sexcol[1])
  shade(apply(predF3,1,PI),descaleT(seqT),col=col.alpha(sexcol[1],0.2))
  lines(descaleT(seqT),apply(predM3,1,mean),col=sexcol[2])
  shade(apply(predM3,1,PI),descaleT(seqT),col=col.alpha(sexcol[2],0.2))  
}

plotAgain()

dev.off()

#TASK 26: Experiment with the plotting functions png, and pdf, png does not know parameter compression, pdf does not know compression nor resolution nor units. Do you know why?
#If you struggle, you can find the solution in TASK_SOLUTIONS.R line 519

#Do not froget to
detach(post)
#when you are done!

